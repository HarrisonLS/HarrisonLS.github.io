import{_ as a,o as e,c as l,R as i}from"./chunks/framework.385be6c2.js";const t="/image/network/dgcx.webp",r="/image/network/ddcx.webp",T=JSON.parse('{"title":"计算机网络 基础知识","description":"","frontmatter":{},"headers":[],"relativePath":"frontEnd/network/index.md","filePath":"frontEnd/network/index.md"}'),o={name:"frontEnd/network/index.md"},h=i('<h1 id="计算机网络-基础知识" tabindex="-1">计算机网络 基础知识 <a class="header-anchor" href="#计算机网络-基础知识" aria-label="Permalink to &quot;计算机网络 基础知识&quot;">​</a></h1><h2 id="_1、http-常见状态码" tabindex="-1">1、HTTP 常见状态码 <a class="header-anchor" href="#_1、http-常见状态码" aria-label="Permalink to &quot;1、HTTP 常见状态码&quot;">​</a></h2><h3 id="_1xx" tabindex="-1">1XX <a class="header-anchor" href="#_1xx" aria-label="Permalink to &quot;1XX&quot;">​</a></h3><ul><li>1xx：接受，继续处理</li><li>103（Early Hints）：客户端应在服务端返回 HTML 前开始预加载资源</li></ul><h3 id="_2xx" tabindex="-1">2XX <a class="header-anchor" href="#_2xx" aria-label="Permalink to &quot;2XX&quot;">​</a></h3><ul><li>200：成功并返回数据</li><li>201：已创建</li><li>202：已接收</li><li>203：成功但未进行授权</li><li>204：成功但无内容</li><li>205：成功并重置内容</li><li>206：成功，部分内容，用于实现断电续传</li></ul><h3 id="_3xx" tabindex="-1">3XX <a class="header-anchor" href="#_3xx" aria-label="Permalink to &quot;3XX&quot;">​</a></h3><ul><li>301： 永久重定向。场景是使用域名跳转，新的 URL 在响应中给出</li><li>302：临时重定向。场景是未登陆的用户跳转登录；浏览器默认使用 get 方式重新发出请求，会导致第一次以 post 请求的参数丢失；（才衍生出了 307 状态码）</li><li>303：临时重定向，强制浏览器将请求方法从 POST 改到 GET；</li><li>304：资源未修改，可使用缓存（协商缓存）</li><li>305：需代理访问</li><li>307：307 和 302 一样是临时重定向，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。</li><li>308：308 和 301 一样是永久重定向，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。</li></ul><h3 id="_4xx" tabindex="-1">4XX <a class="header-anchor" href="#_4xx" aria-label="Permalink to &quot;4XX&quot;">​</a></h3><ul><li>400：请求语法错误</li><li>401：要求身份认证</li><li>403：拒绝请求</li><li>404：资源不存在</li><li>405：请求方法错误或不允许</li></ul><h3 id="_5xx" tabindex="-1">5XX <a class="header-anchor" href="#_5xx" aria-label="Permalink to &quot;5XX&quot;">​</a></h3><ul><li>500：服务器错误</li><li>502：网关错误</li><li>503：服务不可用</li><li>504：网关或代理服务器超时</li></ul><h2 id="_2、浏览器从输入-url-到页面呈现的过程" tabindex="-1">2、浏览器从输入 URL 到页面呈现的过程 <a class="header-anchor" href="#_2、浏览器从输入-url-到页面呈现的过程" aria-label="Permalink to &quot;2、浏览器从输入 URL 到页面呈现的过程&quot;">​</a></h2><h3 id="第一部分-请求响应的过程" tabindex="-1">第一部分 请求响应的过程 <a class="header-anchor" href="#第一部分-请求响应的过程" aria-label="Permalink to &quot;第一部分 请求响应的过程&quot;">​</a></h3><ol><li>解析 url</li><li>DNS 解析，获取实际 IP 地址</li><li>建立 TCP 连接，根据 IP 地址，进行三次握手连接机制</li><li>建立 HTTP 连接</li><li>负载均衡，分配给对应集群服务器获取资源</li><li>服务器响应返回</li><li>浏览器客户端接受 http 响应，响应后根据 connection:keep-alive 的值来选择通过 四次挥手来断开 TCP 连接，或者保留；</li></ol><h3 id="第二部分-解析及渲染资源的过程" tabindex="-1">第二部分 解析及渲染资源的过程 <a class="header-anchor" href="#第二部分-解析及渲染资源的过程" aria-label="Permalink to &quot;第二部分 解析及渲染资源的过程&quot;">​</a></h3><ol><li>构建 DOM 树</li><li>构建 CSSOM 树</li><li>构建渲染树</li><li>布局</li><li>绘制</li></ol><h2 id="_3、http" tabindex="-1">3、HTTP <a class="header-anchor" href="#_3、http" aria-label="Permalink to &quot;3、HTTP&quot;">​</a></h2><p>HTTP 是超文本传输协议，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。</p><h2 id="_4、websocket" tabindex="-1">4、WebSocket <a class="header-anchor" href="#_4、websocket" aria-label="Permalink to &quot;4、WebSocket&quot;">​</a></h2><h2 id="_5、dns" tabindex="-1">5、DNS <a class="header-anchor" href="#_5、dns" aria-label="Permalink to &quot;5、DNS&quot;">​</a></h2><p>DNS 的作用就是通过域名查询到具体的 IP。是应用层协议，通常该协议运行在 UDP 协议之上，使用的是 53 端口号。</p><h3 id="递归查询" tabindex="-1">递归查询 <a class="header-anchor" href="#递归查询" aria-label="Permalink to &quot;递归查询&quot;">​</a></h3><p><img src="'+t+'" alt="递归查询"></p><h3 id="迭代查询" tabindex="-1">迭代查询 <a class="header-anchor" href="#迭代查询" aria-label="Permalink to &quot;迭代查询&quot;">​</a></h3><p><img src="'+r+'" alt="迭代查询"></p><h2 id="_6、https" tabindex="-1">6、HTTPS <a class="header-anchor" href="#_6、https" aria-label="Permalink to &quot;6、HTTPS&quot;">​</a></h2><p>HTTPS 并不是一个新的协议，它只是在 HTTP 和 TCP 的传输中建立了一个安全层，它其实就是 HTTP + SSL/TLS 协议组合而成，而安全性的保证正是 SSL/TLS 所做的工作。</p><h2 id="_7、http2" tabindex="-1">7、HTTP2 <a class="header-anchor" href="#_7、http2" aria-label="Permalink to &quot;7、HTTP2&quot;">​</a></h2><p>参考资料：</p><ul><li><a href="https://web.dev/articles/performance-http2?hl=zh-cn" target="_blank" rel="noreferrer">HTTP/2 简介</a></li><li><a href="https://github.com/woai3c/Front-end-articles/blob/master/http-https-http2.md" target="_blank" rel="noreferrer">半小时搞懂 HTTP、HTTPS 和 HTTP2</a></li></ul><h2 id="计算机网络模型" tabindex="-1">计算机网络模型 <a class="header-anchor" href="#计算机网络模型" aria-label="Permalink to &quot;计算机网络模型&quot;">​</a></h2><h2 id="即时通信方案" tabindex="-1">即时通信方案 <a class="header-anchor" href="#即时通信方案" aria-label="Permalink to &quot;即时通信方案&quot;">​</a></h2><h3 id="方案" tabindex="-1">方案 <a class="header-anchor" href="#方案" aria-label="Permalink to &quot;方案&quot;">​</a></h3><ol><li>短轮询：前端用定时器每隔一段时间就 ajax 向后端获取更新；</li><li>长轮询：长轮询是短轮询的改进，请求到服务端后会被挂起，直到有新的消息才会返回响应；然后再重新发起请求</li><li>基于流 —— SSE：SSE 是一个 H5 的属性，它只能由服务器向浏览器发送数据，所以协作式通过 http 发送消息，sse 接受消息；</li><li>WebSocket： HTML5 开始提供的一种在单个 TCP 连接上进行全双工通信的协议；钉钉表格就是用的原生 WebSocket；</li><li>Socket.io：为了解决 websocket 兼容性的一个方案，将 websocket、长轮询两种通信封装成了统一的通信接口。</li></ol><h3 id="单工、半双工和全双工通信" tabindex="-1">单工、半双工和全双工通信 <a class="header-anchor" href="#单工、半双工和全双工通信" aria-label="Permalink to &quot;单工、半双工和全双工通信&quot;">​</a></h3><ol><li>单工通信：指消息只能单方向传输的工作方式，数据信息从一端到另一端是单方向的。例：广播。</li><li>半双工通信：可以实现双向的通信，但是不能在两个方向同时进行，必须交替进行。这中模式下，接收端和发送端可以互相转换。例：对讲机。</li><li>全双工通信：是指在通信的任意时刻，都允许数据同时在两个方向上传输，在这个模式下，通信系统的每一端都设置了发送器和接收器。</li></ol><h2 id="xss-攻击" tabindex="-1">XSS 攻击 <a class="header-anchor" href="#xss-攻击" aria-label="Permalink to &quot;XSS 攻击&quot;">​</a></h2><h2 id="相关文章" tabindex="-1">相关文章 <a class="header-anchor" href="#相关文章" aria-label="Permalink to &quot;相关文章&quot;">​</a></h2><p><a href="https://juejin.cn/post/7166870049066582053#heading-53" target="_blank" rel="noreferrer">面试知识点复盘【计算机网络】篇</a></p>',40),n=[h];function d(s,c,u,b,_,x){return e(),l("div",null,n)}const p=a(o,[["render",d]]);export{T as __pageData,p as default};
